package chapter03_基础语法_运算符;

public class java_operator {
    public static void main(String[] args){
        //todo 运算符(参与数据运算的符号)
        // 运算符是java定义的,自己无法定义


        //todo 表达式(采用运算符和数据连接在一起形成符合java语法规则的指令代码)


        //todo 1.算术运算符(和c语言相同)
        // 二元运算符:两个元素参与运算的运算符. 例如 1 + 2  //二元运算符:加减乘除和" %(取余) "
        // 有结果就会有类型,这里类型是元素中最大的那个  最小使用的类型是int类型!!!
        // System.out.println(1+2); 结果输出 3
        // System.out.println(5%2); 结果输出 1
        // 一元运算符:一个元素参与运算的运算符. // ++ --
        // 本质是简化版本 加1操作 和c语言相同 ++i,--i,i++;i--;
        //未简化版本
        /* int i = 0;
            int j = i;
           int i = i + 1;  */
        //简化版本(一元运算符的用法)
        // int i = 0;
        // int j = i++;

        //System.out.println("i="+ i);
        //System.out.println("j="+ j);


        //todo 2.赋值运算符(和c语言相同)
        // 等号就是赋值运算符    =      +=,-=,*=,/=,%=,->后面这些叫复合运算符
        // 赋值运算符需要考虑类型的关系
        //赋值运算符例子
        //String name = "zhangsan";
        //byte b = 10;
        //short s = b;

        //todo 2.1.复合运算符   +=,-=,*=,/=,%=
        // 本质还是简化版本
        // 如果使用了复合运算符.那么数据类型不会发生变化
        //复合运算符例子
        //未简化版本
        // int i = 1;
        //i = i + 1;
        //简化版本
        // int i = 1;
        //i += 1;
        //直观例子
        //i *= 1; -->> i = i * 1;
        //i += 1; -->> i = i + 1;
        //i -= 1; -->> i = i - 1;

        //类型变化例子
         //byte b = 10;
        //b = b + 20;//错误例子:这段会报错是因为二元运算单位最小是32位,也就是int  byte->int 得强制转化后才不会报错
        //b = (byte)(b+20);//正确例子 强制转化
        //b += 20;// 复合运算符转化例子  使用了复合运算符.那么数据类型不会发生变化 无需强制转化 不会报精度丢失错误 也算是简化步骤了

        //System.out.println(b);


        //todo 3.关系运算符(用于比较两个数据之间关系的运算符)
        // == != > >= < <=
        // 基本语法结构   关系表达式:元素1(数据1,表达式1) 关系运算符[== != > >= < <=] 元素2(数据2,表达式2)
        // 关系表达式的结果(返回值)是布尔类型(逻辑型)的 结果相同输出true 结果不相同falss




        //todo 4.逻辑运算符(用于描述多个条件表达式之间的关系的运算符)
        // 基本语法结构  变量 = (条件表达式1)  逻辑运算符 (条件表达式2)
        // 条件表达式的结果是布尔类型(逻辑型), 所以逻辑运算符表达式结果(返回值)也是为布尔类型(逻辑型)
        // 这样"条件表达式"就有下面几种情况
        //ture ture -->> ??
        //ture falss -->> ??
        //falss ture -->> ??
        //falss falss -->> ??
        //todo 运用逻辑表达式
        // "&"  称之为"与运算"(结果都喂ture是,最终结果为ture,其中有一个falss,最终结果为falss) "且"
        // "|"  称之为"或运算"(只要其中有一个结果为ture,最终结果为ture,两个结果都为falss,最终结果为falss)
        // "^"  称之为"异或运算(两个真为假,两个假为真,一真一假,一假一真为真)
        // "!"  称之为"非运算"(相反运算)(结果相反)(ture->falss,falss->ture) 结果加了"!"就会变成相反的结果
        // 表达式例子
       /* int i = 10;
        boolean a =(i<5) & (i<20);//"&"和"||"例子 更改逻辑运算符就行
        System.out.println(a);*/

       /* int i = 10;
        boolean a =(i<5) ^ (i<20);//"^"例子
        System.out.println(a);*/

        /*int i = 10;
        boolean a =(i<5) & (i<20);
        System.out.println(!a);//"!"例子*/



        //todo 4.1.短路运算符(可以根据第一个条件表达式的结果来判断是否需要执行第二个条件表达式)
        // "&&" 和 "||" "短路与运算"和"短路或运算"
        // "&&" 如果第一个表达式结果为falss,就不用执行第二个表达式 可以理解为e中的 "且"
        // "||" 如果第一个表达式结果为ture,就不用执行第二个表达式  可以理解为e中的 "或"
        // "&&"和"||"例子
//        int i = 10;
//        int j = 20;
//        boolean a = (i > 20) && (++j > 30);//"&&"例子 如果第一个括号成立 j会等于21 如果第一个不成立 j会等于20
//        boolean a = (i > 20) || (++j > 30);//"||"例子 如果第一个括号成立 j会等于20 如果第一个不成立 j会等于21
//        System.out.println(i);
//        System.out.println(j);
//


        //todo 三元运算符(三个元素参与运算的运算符) “？”
        // 基本语法结构: 变量 = (条件表达式) ? (任意表达式1):(任意表达式2)
        // 用条件表达式的结果来判断执行哪个表达式
        // 如果条件表达式的结果是ture则运行任意表达式1 反之结果为flass则运行任意表达式2
        // 我更认为是别样"如果",例如如果条件达成执行代码,条件不成立执行另一个代码,类似于成功数量和失败数量的联系
        // 例子
//        int i = 15;
//        int j = 20;
//        int k = (i>20) ? 1+3:2+1;
//        System.out.println(k);






    }
}
